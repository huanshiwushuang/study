// man man PageDown PageUp Home End n N / ?  空格 q
// echo $SHELL $PATH 
// date -s '20180919 10:21:09'  +%Y%y%m%d%H%I%M%S%s%j%t%n    %H%I%  ===> %k%l === %_H%_I
// reboot
// poweroff
// wget -rpbtcP
// ps -aux
// top
// pidof
// kill
// killall
// ifconfig
// uname -a
// uptime
// free -h
// tr [a-z] [A-Z]
// wc -lwcm
// stat 文件名
// cut -d: -f1 /etc/passwd
// who
// last
// history -c                 ~/.bash_history   !num   /etc/profile HISTSIZE
// sosreport
// pwd
// cd - .. / ~ ~username
// ls -l -a -d
// dd if= of= bs= count=
// file 

// tar -cxzvfpPtC

// grep -nvicb

// find
// -name	匹配名称
// -perm	匹配权限（mode为完全匹配，-mode为包含即可）
// -user	匹配所有者
// -group	匹配所有组
// -mtime -n +n	匹配修改内容的时间（-n指n天以内，+n指n天以前）
// -atime -n +n	匹配访问文件的时间（-n指n天以内，+n指n天以前）
// -ctime -n +n	匹配修改文件权限的时间（-n指n天以内，+n指n天以前）
// -nouser	匹配无所有者的文件
// -nogroup	匹配无所有组的文件
// -newer f1 !f2	匹配比文件f1新但比f2旧的文件
// -type b/d/c/p/l/f	匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件）
// -size	匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件）
// -prune	忽略某个目录
// -exec …… {}\;	后面可跟用于进一步处理搜索结果的命令（下文会有演示）



// >	>>	2>	2>>	 2>&1	&>

// echo "linuxprobe" | passwd --stdin root

// *?[0-9][135]

// 反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。

// 单引号（''）：转义其中所有的变量为单纯的字符串。

// 双引号（""）：保留其中的变量属性，不进行转义处理。

// 反引号（``）：把其中的命令执行后返回结果。

// lsb_release -a

// env

// export


// dd	
// 5dd	
// yy	
// 5yy	
// n	
// N	
// u	
// p	

// :s/one/two	将当前光标所在行的第一个one替换成two
// :s/one/two/g	将当前光标所在行的所有one替换成two
// :%s/one/two/g	将全文中的所有one替换成two


// /etc/sysconfig/network-scripts
// ifcfg-

// 设备类型：TYPE=Ethernet
// 地址分配模式：BOOTPROTO=static
// 网卡名称：NAME=eno16777736
// 是否启动：ONBOOT=yes
// IP地址：IPADDR=192.168.10.10
// 子网掩码：NETMASK=255.255.255.0
// 网关地址：GATEWAY=192.168.10.1
// DNS地址：DNS1=192.168.10.1

// ?????????????????????????????????????????????????????????????????????????????????????????????????????
// https://www.linuxprobe.com/chapter-04.html  yum 仓库没有看懂 需要后面的知识再来回顾
// ?????????????????????????????????????????????????????????????????????????????????????????????????????

// $#对应的是总共有几个参数，$*对应的是所有位置的参数值，$?对应的是显示上一次命令的执行返回值

// -d	测试文件是否为目录类型
// -e	测试文件是否存在
// -f	判断是否为一般文件
// -r	测试当前用户是否有权限读取
// -w	测试当前用户是否有权限写入
// -x	测试当前用户是否有权限执行


// if [ 左右要有空格哦 ]

// = != && ||

// -eq	是否等于
// -ne	是否不等于
// -gt	是否大于
// -lt	是否小于
// -le	是否等于或小于
// -ge	是否大于或等于

// =	比较字符串内容是否相同
// !=	比较字符串内容是否不同
// -z	判断字符串内容是否为空

// if
// 	then 内容
// elif
// 	then 内容
// else
// 	内容
// fi

// if [ $GRADE -ge 85 ] && [ $GRADE -le 100 ]

// read -p '提示信息' 变量


// for i in list
// do
// 内容
// done




// PRICE=$(expr $RANDOM % 1000)
// TIMES=0
// let TIMES++

// while true
// do
// 内容
// exit 0
// done


// case "$key" in
// [a-z][A-Z])
// 内容
// ;;
// [0-9])
// 内容
// ;;
// *)
// 内容
// esac

// 一次性的计划任务用 at ，具体查看 man at，能看懂个大概
// at 13:49 2018-11-17
// ctrl+d
// at -l
// atrm id

// 周期性重复执行的计划任务用 crond：
// 	创建、编辑计划任务的命令为	“crontab -e”，
// 	查看当前计划任务的命令为	“crontab -l”，
// 	删除某条计划任务的命令为	“crontab -r”
// 	如果您是以管理员的身份登录的系统，还可以在crontab命令中加上-u参数来编辑他人的计划任务
// 口诀“分、时、日、月、星期 命令”。这是使用crond服务设置任务的参数格式
// 字段没有设置，则需要使用星号（*）占位

// 技巧：
// 除了用逗号（,）来分别表示多个时间段，例如“8,9,12”表示8月、9月和12月。还可以用减号（-）来表示一段连续的时间周期
// 以及用除号（/）表示执行任务的间隔时间（例如“*/2”表示每隔2分钟执行一次任务）。
// 命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用whereis命令进行查询



// 管理员UID为0：系统的管理员用户。

// 系统用户UID为1～999： Linux系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会有独立的系统用户负责运行，进而有效控制被破坏范围。

// 普通用户UID从1000开始：是由管理员创建的用于日常工作的用户。



// useradd命令
// -d	指定用户的家目录（默认为/home/username）
// -e	账户的到期时间，格式为YYYY-MM-DD.
// -u	指定该用户的默认UID
// -g	指定一个初始的用户基本组（必须已存在）
// -G	指定一个或多个扩展用户组
// -N	不创建与用户同名的基本用户组
// -s	指定该用户的默认Shell解释器
// 请注意/sbin/nologin，它是终端解释器中的一员，与Bash解释器有着天壤之别。
// 一旦用户的解释器被设置为nologin，则代表该用户不能登录到系统中：

// groupadd [选项] 群组名

// usermod命令用于修改用户的属性，格式为“usermod [选项] 用户名”
// -c	填写用户账户的备注信息
// -d -m	参数-m与参数-d连用，可重新指定用户的家目录并自动把旧的数据转移过去
// -e	账户的到期时间，格式为YYYY-MM-DD
// -g	变更所属用户组
// -G	变更扩展用户组
// -L	锁定用户禁止其登录系统
// -U	解锁用户，允许其登录系统
// -s	变更默认终端
// -u	修改用户的UID

// passwd [选项] [用户名]
// -l	锁定用户，禁止其登录
// -u	解除锁定，允许用户登录
// --stdin	允许通过标准输入修改用户密码，如echo "NewPassWord" | passwd --stdin Username
// -d	使该用户可用空密码登录系统
// -e	强制用户在下次登录时修改密码
// -S	显示用户的密码是否被锁定，以及密码所采用的加密算法名称

// userdel [选项] 用户名
// -f	强制删除用户
// -r	同时删除用户及用户家目录



// 在复杂多变的生产环境中，单纯设置文件的rwx权限无法满足我们对安全和灵活性的需求，因此便有了SUID、SGID与SBIT的特殊权限位
// 查看passwd命令属性时发现所有者的权限由rwx变成了rws，
// 其中x改变成s就意味着该文件被赋予了SUID权限。
// 另外有读者会好奇，那么如果原本的权限是rw-呢？如果原先权限位上没有x执行权限，那么被赋予特殊权限后将变成大写的S。


// SGID主要实现如下两种功能：
// 让执行者临时拥有属组的权限（对拥有执行权限的二进制程序进行设置）；
// 在某个目录中创建的文件自动继承该目录的用户组（只可以对目录进行设置）。
// chmod g+s gh  给文件夹的组变为sgid权限，然后此文件夹下新创建的文件夹自动继承对应的s


// chmod [参数] 权限 文件或目录名称
// chown [参数] 所有者:所属组 文件或目录名称
// 针对目录进行操作时需要加上大写参数-R来表示递归操作，即对目录内所有的文件进行整体操作
// u+-rwx  g+=rwx o+-rwx

// SBIT
// 当对某个目录设置了SBIT粘滞位权限后，那么该目录中的文件就只能被其所有者执行删除操作了。
// 与前面所讲的SUID和SGID权限显示方法不同，当目录被设置SBIT特殊权限位后，文件的其他人权限部分的x执行权限就会被替换成t或者T，原本有x执行权限则会写成t，原本没有x执行权限则会被写成T。


// chattr命令用于设置文件的隐藏权限
// chattr [参数] 文件  例子：chattr +a linuxprobe
// 如果想要把某个隐藏功能添加到文件上，则需要在命令后面追加“+参数”，如果想要把某个隐藏功能移出文件，则需要追加“-参数”。
// i	无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件
// a	仅允许补充（追加）内容，无法覆盖/删除内容（Append Only）
// S	文件内容在变更后立即同步到硬盘（sync）
// s	彻底从硬盘中删除，不可恢复（用0填充原文件所在硬盘区域）
// A	不再修改这个文件或目录的最后访问时间（atime）
// b	不再修改文件或目录的存取时间
// D	检查压缩文件中的错误
// d	使用dump命令备份时忽略本文件/目录
// c	默认将文件或目录进行压缩
// u	当删除该文件后依然保留其在硬盘中的数据，方便日后恢复
// t	让文件系统支持尾部合并（tail-merging）
// x	可以直接访问压缩文件中的内容

// lsattr命令用于显示文件的隐藏权限，格式为“lsattr [参数] 文件”



// 接下来是：5.5 文件访问控制列表
// setfacl [参数] 文件名称
// 针对目录文件需要使用-R递归参数；针对普通文件则使用-m参数；
// 如果想要删除某个文件的ACL，则可以使用-b参数全部删除；使用 -x 删除指定用户或组  setfacl -x u:gh /root
// 	setfacl -Rm u:linuxprobe:rwx /root

// 上面的su命令与用户名之间有一个减号（-），这意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息。强烈建议在切换用户身份时添加这个减号（-）


// sudo [参数] 命令名称
// -h	列出帮助信息
// -l	列出当前用户可执行的命令
// -u 	用户名或UID值	以指定的用户身份执行命令
// -k	清空密码的有效时间，下次执行sudo时需要再次进行密码验证
// -b	在后台执行指定的命令
// -p	更改询问密码的提示语

// 总结来说，sudo命令具有如下功能：
// 	限制用户执行指定的命令：
// 	记录用户执行的每一条命令；
// 	配置文件（/etc/sudoers）提供集中的用户管理、权限与主机等参数；
// 	验证密码的后5分钟内（默认值）无须再让用户再次验证密码。

// 当然，如果担心直接修改配置文件会出现问题，则可以使用sudo命令提供的visudo命令来配置用户权限。这条命令在配置用户权限时将禁止多个用户同时修改sudoers配置文件，还可以对配置文件内的参数进行语法检查，并在发现参数错误时进行报错。
// 只有root管理员才可以使用visudo命令编辑sudo服务的配置文件。

// 谁可以使用  允许使用的主机=（以谁的身份）  可执行命令的列表
// 97 ## Allow root to run any commands anywhere
// 98 root ALL=(ALL) ALL
// 99 linuxprobe ALL=(ALL) ALL
// 	无须频繁的验证密码
//    linuxprobe ALL=NOPASSWD: /usr/sbin/poweroff






// /boot	开机所需文件—内核、开机菜单以及所需配置文件等
// /dev	以文件形式存放任何设备与接口
// /etc	配置文件
// /home	用户主目录
// /bin	存放单用户模式下还可以操作的命令
// /lib	开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数
// /sbin	开机过程中需要的命令
// /media	用于挂载设备文件的目录
// /opt	放置第三方的软件
// /root	系统管理员的家目录
// /srv	一些网络服务的数据文件目录
// /tmp	任何人均可使用的“共享”临时目录
// /proc	虚拟文件系统，例如系统内核、进程、外部设备及网络状态等
// /usr/local	用户自行安装的软件
// /usr/sbin	Linux系统开机时不会使用到的软件/命令/脚本
// /usr/share	帮助与说明文件，也可放置共享文件
// /var	主要存放经常变化的文件，如日志
// /lost+found	当文件系统发生错误时，将一些丢失的文件片段存放在这里

// Linux系统中常见的硬件设备的文件名称如表6-2所示。
// 	IDE设备	/dev/hd[a-d]
// 	SCSI/SATA/U盘	/dev/sd[a-p]
// 	软驱	/dev/fd[0-1]
// 	打印机	/dev/lp[0-15]
// 	光驱	/dev/cdrom
// 	鼠标	/dev/mouse
// 	磁带机	/dev/st0或/dev/ht0




// mount 文件系统 挂载目录
// -a	挂载所有在/etc/fstab中定义的文件系统
// -t	指定文件系统的类型

// 系统在重启后挂载就会失效
// 必须把挂载信息按照指定的填写格式“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”（各字段的意义见表6-4）写入到/etc/fstab文件中

// 设备文件	一般为设备的路径+设备名称，也可以写唯一识别码（UUID，Universally Unique Identifier）
// 挂载目录	指定要挂载到的目录，需在挂载前创建好
// 格式类型	指定文件系统的格式，比如Ext3、Ext4、XFS、SWAP、iso9660（此为光盘设备）等
// 权限选项	若设置为defaults，则默认权限为：rw, suid, dev, exec, auto, nouser, async
// 是否备份	若为1则开机后使用dump进行磁盘备份，为0则不备份
// 是否自检	若为1则开机后自动进行磁盘自检，为0则不自检


// umount [挂载点/设备文件]
// umount /dev/sdb2


// ln命令
// -s	创建“符号链接”（如果不带-s参数，则默认创建硬链接）
// -f	强制创建文件或目录的链接
// -i	覆盖前先询问
// -v	显示创建链接的过程


// 添加硬盘设备

// 后台运行
[后台运行](https://www.cnblogs.com/zzyoucan/p/7764590.html)


















