// ---PS----------------------------------------------------------------------------------
// 1、sass不能被滥用，可能生成的样式表会很大
// 2、规则嵌套：选择器嵌套、属性嵌套
// 3、作用域如你想的那样，以花括号为界限
// 4、关键词：变量、嵌套规则、导入、混合、继承
// 5、
// 6、
// 7、

// ---变量----------------------------------------------------------------------------------
// 1、变量以 $ 开头，区别于 less 的 @

// 2、老版本的sass使用!来标识变量

// 3、变量的值可以为任意你所知道的css 某个样式的值

// 4、变量的作用域同 js 类比

// 5、变量被引用，可以组合到任意 css 某个样式的值，变量可以相互引用

// 6、变量 短横线 和 下划线，定义和使用可以互换。

// 7、!default 修饰的变量权重低，之后没有被声明覆盖才会使用这个值
    // 例如：$name: 张三!default;

// ---嵌套规则----------------------------------------------------------------------------------
// 1、普通花括号的规则嵌套

// 2、& 符号会被父选择器替代，常用于 :hover 之类的
    // 记住这种特殊用法：
    // #content aside {
    //   color: red;
    //   body.ie & { color: green }
    // }

// 3、群组嵌套也会按照常规解开

// 4、> + ~ 子代、相邻、后面同层 选择器解开规则和普通的一样

// 5、属性嵌套之---属性后面的花括号里面写值。从短横线处断开。
    // nav {
    //     border: {
    //         style: solid;
    //         width: 1px;
    //         color: #ccc;
    //     }
    // }
// 6、属性嵌套之---属性后面的值后面的花括号里面写值。花括号里的同样会常规解开
    // nav {
    //     border: 1px solid #ccc {
    //         left: 0px;
    //         right: 0px;
    //     }
    // }
// ---SASS导入----------------------------------------------------------------------------------
// 1、导入 .sass 或者 .scss 可以省略后缀

// 2、以下划线开头的 sass 文件是 局部文件 不会生成 css 文件。下划线和后缀都可以省略
    // 文件_color.sass ---》 @import "color"

// 3、@import 导入可以直接嵌套替代位置

// 4、css 文件不会被 sass 导入，会被原生css语法导入，所以导入一个css文件可以将后缀改为 sass scss

// 5、指向css的url()方法会使用原生导入

// 6、指向url的会使用原生导入

// 7、// 注释会被 sass 去掉， /* */ 注释不会被去掉

// 8、当注释被写在 不正常 的地方时，生成的css注释也会被抹去
    // color /* 这块注释内容不会出现在生成的css中 */: #333;

// ---混合器----------------------------------------------------------------------------------
// 1、使用 @mixin 定义
    // @mixin rounded-corners {

    // }

// 2、@include 引用
    // notification {
    //     background: #f00;
    //     @include rounded-corners;
    // }

// 3、判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。

// 4、css类和混合器类似。区别在于：css类用于html元素，取名是语义化的，特定于某个具体情况。
// 而混合器取名是外观化的，与结构和具体用处环境无关。

// 5、混合器中不仅可以写css属性，也可以写css嵌套规则

// 6、如果一个混合器只包含css规则，不包含属性，那么这个混合器就可以在文档的顶部调用，写在所有的css规则之外

// 7、混合器传参：当做 js 函数用
    // @mixin name(a,b) {}
    // @include name(1,2)
    // 传参的时候，为了不用记忆参数顺序，可以以键值对的形式传参
    // @include name($a: 2,$b: 1)
    // 可以不用传入所有参数，使用定义时候的默认值
    // @mixin name(a, b: a) {}

// 8、选择器继承：@extend
    // .a {}
    // .b {@extend .a;}
    // 所有跟 被继承 类 有关的样式都会作用于 继承的类，效果类似于 class="a b"

// 9、继承和类有关系，所以继承也应该是建立在语义化的基础上。顾名思义，在结构或表现上有父子关系的可以考虑继承
// 参考 java 的继承，有面向对象的思想。记得给类取名字的时候考虑好继承的关系。


// 10、假如一条样式规则继承了一个复杂的选择器，那么它只会继承这个复杂选择器命中的元素所应用的样式。

// 11、像#main .error这种选择器序列是不能被继承的。这是因为从#main .error中继承的样式一般情况下会跟直接从.error中继承的样式基本一致

// 12、继承是建立在选择器的基础上。可以继承标签选择器
    // .disabled {
    //     color: gray;
    //     @extend a;
    // }
// 13、继承的原理： .a @extend .b； 父类选择器会被替换成 父类+子类的群组选择器 = .a,.b

// 14、跟混合器相比，继承生成的css代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的css体积更小。
    // 继承是 生成群组选择器；而混合是直接导入样式。样式的重复往往比选择器的重复内容更多。

// 15、值得一提的是，只要你想，你完全可以放心地继承有后代选择器修饰规则的选择器，不管后代选择器多长，但有一个前提就是，不要用后代选择器去继承
    // 【不要用后代选择器去继承、不要用后代选择器去继承、不要用后代选择器去继承】
    // 原理可以看看在 https://www.sassmeister.com/ 
    // .foo .bar { @extend .baz; }  
    // .bip .baz { width: 100px; }
    // 的编译结果

// End