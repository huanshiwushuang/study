// http://es6.ruanyifeng.com/#docs/intro

// 1、暂时性死区  typeof 不再百分百安全

// 2、ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
// ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。
// 浏览器的实现可以不遵守上面的规定，有自己的行为方式。

// 3、ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。

// 4、const 之于 对象。如果真的想将对象冻结，应该使用Object.freeze方法。

// 5、ES6 一共有 6 种声明变量的方法： var function let const import class

// 6、var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性
// 重点

// 解构赋值：解构赋值允许指定默认值。let [foo = true] = [];默认值可以引用解构赋值的其他变量，但该变量必须已经声明
// 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。

// 8、如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
// function f() {
//     console.log('aaa');
// }
// let [x = f()] = [1];

// 9、解构不仅可以用于数组，还可以用于对象。let { foo, bar } = { foo: "aaa", bar: "bbb" }; 真实的非简写格式是：let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };

// 10、如果变量名与属性名不一致，必须写成下面这样。
// let { foo: baz } = { foo: 'aaa', bar: 'bbb' }; 考虑理解为 foo as baz
// baz // "aaa"

// 11、解构也可以用于嵌套结构的对象。
// let obj = {
//     p: [
//         'Hello',
//         { y: 'World' }
//     ]
// };
// let { p: [x, { y }] } = obj;
// x // "Hello"
// y // "World"

// 12、对象解构可以重复有相同名字进行赋值：let { p, p: [x, { y }] } = obj;
// 对象解构：冒号前面是匹配的名字模式，后面才是变量

// 13、对象的解构也可以指定默认值。生效的原则同数组的解构。 第6
// var { x = 3 } = {};
// var { x: y = 3 } = {};

// 14、next:且子对象所在的父属性不存

// 15、

// 16、

// 17、

// 18、

// 19、

// 20、
